<?php
// $id


/**
 * Implementation of hook_theme()
 *
 * @return array
 */
function node_map_theme($existing, $type, $theme, $path) {
  return array(
    'node_map_settings' => array(
      'arguments' => array(
        'form' => null
      ),
    ),
  );
}

/**
 * Themes the settings form
 *
 * @return string
 */
function theme_node_map_settings($form) {
  $output = '';
  $rows = array();
  
  foreach (element_children($form['name']) as $key) {
    $rows[] = array(
      drupal_render($form['use_map'][$key]),
      drupal_render($form['name'][$key]),
    );
  }

  $output .= theme('table', $form['header']['#value'], $rows);  // render the table
  $output .= drupal_render($form);  // output the rest of the form
  return $output;
}

/**
 * Settings form form Taxonomy Map
 * @return array
 */
function node_map_settings() {
  $form = array();
  // set header
  $form['header'] = array(
    '#type' => 'value',
    '#value' => array(theme('table_select_header_cell'), t('Name')),
  );

  // gather data
  $options = array();
  $types = db_query('SELECT `type`, `name` FROM {node_type}');
  while ($type = db_fetch_object($types)) {
    $options[$type->type] = '';
    $form['use_map'][$type->type] = '';
    $form['name'][$type->type] = array('#value' => l($type->name, sprintf('node_map/%s', $type->type)));
  }

  $form['use_map'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#default_value' => variable_get('node_map_enabled_nodes', array()),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  $form['cancel'] = array(
    '#type' => 'markup',
    '#value' => l(t('Cancel'), 'settings'), 
  );

  return $form;
}

/**
 * Submits data from node map settings page
 *
 * @param array $form
 * @param array $form_state
 * @return void
 */
function node_map_settings_submit($form, &$form_state) {
  $enabled = array();
  foreach ($form_state['values']['use_map'] as $key => $val) {
    if ($val) {
      $enabled[] = $key;
    }
  }
  variable_set('node_map_enabled_nodes', $enabled);
}

/**
 * Renders node map page
 *
 * @param  string $type
 * @return void
 */
function node_map_page() {
  $type = func_get_arg(0);
  $type = strip_tags($type);
  $enabled = variable_get('node_map_enabled_nodes', array());
  if (!in_array($type, $enabled)) {
    drupal_set_message(sprintf('Node map for type "%s" is disabled.', $type), 'error');
    drupal_access_denied();
    return;
  }

  // Render the map
  $dir = drupal_get_path('module', 'node_map');
  drupal_add_css($dir . '/css/node_map.css');
  drupal_set_html_head('<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>');
  drupal_add_js($dir . '/js/node_map.js');
  $output = sprintf('<div id="node_map" data-node-type="%s"></div>', $type);
  return $output;
}

/**
 * Processes directory w/ markers
 *
 * @param string $path
 * @return array
 */
function _node_map_process_marker_dir($path) {
  global $base_url;
  static $fields = array('shadow', 'anchorX', 'anchorY', 'infoX', 'infoY');
  $markerdata = array();
  $inifiles = file_scan_directory($path, '.*\.ini$');
  foreach ($inifiles as $inifile) {
    $tpath = substr($inifile->filename, strlen($path), -strlen($inifile->basename));;
    $ini = parse_ini_file($inifile->filename, TRUE);
    $defaults = isset($ini['defaults']) ? $ini['defaults'] : array();
    unset($ini['defaults']);
    foreach ($ini as $title => $section) {
      // @@@TODO: more compact data storage
      $markerobj = new stdClass();
      $markerobj->path = $base_url . '/' . $path . $tpath;

      if (!isset($section['name']) || !isset($section['sequence']))
        continue; // invalid marker definition
      $markerobj->name = $section['name'];
      $markerobj->iconfile = explode(',', $section['sequence'], 1);
      $markerobj->iconfile = $markerobj->iconfile[0];

      foreach ($fields as $field) {
        $markerobj->$field = isset($section[$field]) ? $section[$field] :
          (isset($defaults[$field]) ? $defaults[$field] : '');
      }
      $markerdata[$title] = $markerobj;
      unset($markerobj);
    }
    unset($ini);
  }
  return $markerdata;
}


/**
 * Gathers marker info
 *
 * @param bool $reset
 * @return void
 */
function _node_map_get_marker_info($reset = FALSE) {
  if ($reset || !($markerdata = cache_get('node_map_marker_info')))
  {
    $markerdir = variable_get('gmap_markerfiles', drupal_get_path('module', 'gmap') .'/markers');
    $markerdata = _node_map_process_marker_dir($markerdir);
    cache_set('node_map_marker_info', $markerdata);
  }
  else
    $markerdata = $markerdata->data;
  return $markerdata;
}


/**
 * Implementaion of hook_flush_caches()
 *
 * @return void
 */
function node_map_flush_caches() {
//  cache_clear_all('node_map_marker_info');
}

/**
 * Checks if specified node type is allowed to have map
 *
 * @param  string $type
 * @return void
 */
function _node_map_type_check($type) {
  $enabled = variable_get('node_map_enabled_nodes', array());
  if (!$type || !in_array($type, $enabled)) {
    drupal_access_denied();
    return false;
  }
  return true;
}

/**
 * Provides markers data for js part of the app
 *
 * @param array $args
 * @return void
 */
function _node_map_ajax_callback_markers($args) {
  $type = array_shift($args);
  if (!_node_map_type_check($type))
    return;

  $markerdata = _node_map_get_marker_info(TRUE); // @@@TODO: remove the parameter after debugging to enable caching
  $result = array();
  $q = sprintf('SELECT {location_marker}.*, {location}.*, {node}.nid, {node}.title FROM {location_marker} '
    . 'INNER JOIN {location} ON {location_marker}.lid = {location}.lid '
    . 'INNER JOIN {location_instance} ON {location_marker}.lid = {location_instance}.lid '
    . 'INNER JOIN {node} ON {node}.nid = {location_instance}.nid '
    . 'WHERE {node}.type="%s"', db_escape_string($type));
  $r = db_query($q);
  while ($row = db_fetch_object($r)) {
    if (!$row->marker) {
      $row->marker = 'big red';   // @@@TODO: make default marker an option
    }
    $row->marker = isset($markerdata[$row->marker]) ? $markerdata[$row->marker] : null;
    $result[] = $row;
  }
  // Send data to client
  header('Content-Type: text/javascript; charset: UTF-8');
  print(json_encode($result));
  exit();  
}

/**
 * Provides node info for baloon tips
 *
 * @param  $args
 * @return void
 */
function _node_map_ajax_callback_info($args) {
  $nid = array_shift($args);
  printf('<strong>This is node with nid = %d</strong>', $nid);
  exit();
}

/**
 * Node Map ajax callback
 *
 * @return void
 */
function node_map_ajax_callback() {
  $args = func_get_args();
  $op = array_shift($args);
  switch ($op) {
    case 'markers':
      return _node_map_ajax_callback_markers($args);
    case 'info':
      return _node_map_ajax_callback_info($args);
  }
}

/**
 * Implementation of hook_menu()
 *
 * @return array
 */
function node_map_menu() {
  $items = array();
  $items['admin/settings/node_map'] = array(
    'title' => t('Node Map'),
    'description' => 'Configure Node Map.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_map_settings'),
    'access arguments' => array('administer node map'),
    'type' => MENU_CALLBACK,
  );
  $items['node_map_callback/%/%'] = array(
    'title' => 'Node Map ajax callback',
    'page callback' => 'node_map_ajax_callback',
    'page arguments' => array(1, 2),
    'access arguments' => array('access node map'),
    'type' => MENU_CALLBACK,
  );
  $items['node_map/%'] = array(
    'title' => t('Node Map'),
    'page callback' => 'node_map_page',
    'page arguments' => array(1),
    'access arguments' => array('access node map'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_perm()
 *
 * @return array
 */
function node_map_perm() {
  return array('access node map');
}

/**
 * Implementaion of hook_help()
 * Displays help and module information
 *
 * @param string $path
 * @param array $arg
 * @return string
 */
function node_map_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#node_map':
      $output = '<p>'.t('Displays Node Map pages').'</p>';
      break;
  }
  return $output;
}
